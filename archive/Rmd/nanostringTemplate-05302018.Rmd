---
title: "NanoString Analysis Template"
author: "Caleb A Class"
runtime: shiny
output: html_document
---

<style>
.col2 {
  columns: 2 200px;         /* number of columns and width in pixels*/
  -webkit-columns: 2 200px; /* chrome, safari */
  -moz-columns: 2 200px;    /* firefox */
}
.column-left{
  float: left;
  width: 67%;
  text-align: left;
}
.column-right{
  float: right;
  width: 33%;
  text-align: right;
}
</style>



```{r userInput, include = FALSE, echo = FALSE}
# This is the only part to be edited by the standard user. Advanced users might want to adjust
# normalization or analysis parameters in 2nd code block.

# The folder containing .RCC files (can also be .zip folder)
file.folder <- "Y:/R/CCCT/CC04_ICC/nanoStringData/lung_ms/20180403_gibbons chip8 040318_RCC/"

# Housekeeping genes for normalization (if NULL, will use genes marked as housekeeping in
# .RCC files)  --> housekeeping table in quickbase
hk.genes <- c("ALAS1", "ABCF1", "TBP", "PPIA", "TUBB")

# Group identifiers (treatment/etc.). Can be manual input or from file.
# If manual, they must be the same length and in the same order as files in folder (careful!).
# If NULL, they will be obtained from file names (must be between a space and an underscore). This works
# for lung_ms data, we can revisit when we have standardized file/sample names.
# If reading in file, use stringsAsFactors = FALSE.
groups <- NULL

# The standard analysis will compare all treatment groups against vehicle (the "base.group", which must
# be one of the "groups").
base.group <- "igg"

# Gene set file in .rds or .gmt format
# Runs fast with hallmark/reactome, C7 could take a minute or two
geneset.file <- "C:/Users/CAClass/Documents/R/scripts_GSEA_2015/GeneSetDatabases/H-Re_v6.1.rds"

```

```{r loadAndAnalyze, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, fig.height = 4, fig.width = 5)

# in NanoTube folder:
#devtools::install(".")
library(rlang)
library(Biobase)
library(limma)
library(plotly)
library(ggplot2)
library(DT)
library(NanoTube)

nanostringData <- processNanostringData(file.folder,
                             bgType = "t.test", bgPVal = 0.001,
                             housekeeping = hk.genes,
                             includeQC = TRUE)

# This is only to generate background data for the QC report
nanostringDataBG <- processNanostringData(file.folder,
                             bgType = "threshold", bgThreshold = 2, bgProportion = 0.5,
                             housekeeping = hk.genes,
                             includeQC = TRUE)

colnames(nanostringData$exprs) <- 
  colnames(nanostringData$exprs.raw) <-
  names(nanostringData$pc.scalefactors) <-
  names(nanostringData$hk.scalefactors) <-
  colnames(nanostringData$qc) <- 
  rownames(nanostringDataBG$bg.stats) <-
  gsub(".* |\\.RCC", "", colnames(nanostringData$exprs))

if (is.null(groups)) groups <- gsub("_.*", "", colnames(nanostringData$exprs))

limmaResults <- runLimmaAnalysis(nanostringData, groups, base.group)
#makeDiffExprFile(limmaResults, base.group, filename = NULL)

# q-value calculated by benjamini-hochberg, not accurate for pathway analysis since pathways aren't independent
# (fgsea also does this)
genesetResults <- mHG.genesets.multi(limmaResults, geneset.file,
                               t_thresh = 2, numReq_overall = 10, numReq_inSet = 5)


```


```{r textOutputs, include = FALSE, eval = FALSE}
# QC file
#nanostringForQC <- processNanostringData(file.folder,
#                             bgType = "threshold", bgThreshold = 2, bgProportion = 0.5,
#                             housekeeping = hk.genes,
#                             includeQC = TRUE)
#write.csv(nanostringForQC$bg.stats, paste0(file.folder, "../chips78/chip8-background.csv"))

# Differential expression file
#makeDiffExprFile(limmaResults, base.group, 
#                 filename = paste0(file.folder, "../chips78/chip8_diffExpr.txt"))

#source("Y:/R/CCCT/functions/danaher.heatmap.R")
#danaher.diffExpr(limmaResults, base.group, input.org = "Mu",
#                 filename = paste0(file.folder, "../20180418-24_immuneSig_diffExpr.txt"))

# Pathway files
#leadingEdge <- mHG.to.LEdge.multi(genesetResults, limmaResults$t, 
#                                  t.thresh = 2, q.thresh = 0.1, geneset.file)
#grouped <-   groupByDistance(genesetResults[[1]][[2]], 
#                                  leadingEdge[[1]][[2]], 
#                                  join.threshold = 0.5)
#prep.stackedReport.from.grouped.mHG(grouped, leadingEdge[[1]][[2]], limmaResults, base.group,
#                                    filename = paste0(file.folder, "../chips78/chip8_pd1Negative-c7"))

```

# {.tabset}

## QC, normalization, and methods {.tabset}

`r length(limmaResults$sampleData$group)` samples were analyzed from `r length(unique(limmaResults$sampleData$group))` groups (these are shown in the table below). Log2-transformed raw counts are presented in Figure 1. `r sum(nanostringData$dict$CodeClass == "Endogenous")` of `r sum(nanostringData$dict.raw$CodeClass == "Endogenous")` endogenous genes were detected significantly above the negative control genes, and these were normalized by both positive controls and housekeeping genes prior to analysis. Post-normalization expression of genes included in analysis are presented in Figure 2.

Differential expression was analyzed using the empirical Bayes method in limma, comparing all groups against `r base.group`. Gene set enrichment was analyzed using the minimum hypergeometric test, with the mHG library. Leading edge genes (with t > 2 in the analysis direction) were clustered using binomial distance.

### Positive Controls

```{r positivePrep, include = FALSE}

# Observed vs. Expected for positive control genes

dat.pos <- as.data.frame(log2(nanostringData$exprs.raw[nanostringData$dict.raw$CodeClass == "Positive",]))
dat.pos$Expected <- log2(as.numeric(gsub(".*\\(|\\)", "", nanostringData$dict.raw$Name[nanostringData$dict.raw$CodeClass == "Positive"])))

dat.pos.df <- reshape::melt(dat.pos, "Expected")
colnames(dat.pos.df)[2:3] <- c("Sample", "Observed")

samps <- unique(dat.pos.df$Sample)
xmin <- min(dat.pos.df$Expected)
xmax <- max(dat.pos.df$Expected)
ymax <- max(dat.pos.df$Observed)

pos1 <- ggplot(data = dat.pos.df[dat.pos.df$Sample %in% samps[1:3],], 
               aes(x = Expected, y = Observed)) + 
  geom_point(aes(fill = Sample), colour ="black", pch=21, size=3) + xlim(xmin, xmax) + ylim(0, ymax) +
  scale_fill_manual(values = c("white", "grey70", "black")) + theme_classic()
pos2 <- ggplot(data = dat.pos.df[dat.pos.df$Sample %in% samps[4:6],], 
               aes(x = Expected, y = Observed)) + 
  geom_point(aes(fill = Sample), colour ="black", pch=21, size=3) + xlim(xmin, xmax) + ylim(0, ymax) +
  scale_fill_manual(values = c("white", "grey70", "black")) + theme_classic()
pos3 <- ggplot(data = dat.pos.df[dat.pos.df$Sample %in% samps[7:9],], 
               aes(x = Expected, y = Observed)) + 
  geom_point(aes(fill = Sample), colour ="black", pch=21, size=3) + xlim(xmin, xmax) + ylim(0, ymax) +
  scale_fill_manual(values = c("white", "grey70", "black")) + theme_classic()
pos4 <- ggplot(data = dat.pos.df[dat.pos.df$Sample %in% samps[10:12],], 
               aes(x = Expected, y = Observed)) + 
  geom_point(aes(fill = Sample), colour ="black", pch=21, size=3) + xlim(xmin, xmax) + ylim(0, ymax) +
  scale_fill_manual(values = c("white", "grey70", "black")) + theme_classic()

# Scale factor table
pos.tab <- data.frame(Sample = names(nanostringData$pc.scalefactors),
                      `Scale Factor` = round(nanostringData$pc.scalefactors, 2))

```

<div class="column-left">
```{r positivePlot, fig.width = 8, fig.height = 6}
multiplot(pos1, pos2, pos3, pos4, cols=2)
```
</div>

<div class="column-right">
```{r positiveTable}
knitr::kable(pos.tab, padding=2, format="html", row.names = FALSE) %>%
  kableExtra::kable_styling(full_width = F)
```
</div>

### Negative Controls
```{r negativePrep, include = FALSE}
# Strip plot for negative control genes
dat.neg <- as.data.frame(nanostringData$exprs.raw[nanostringData$dict.raw$CodeClass == "Negative",])
dat.neg$Gene <- nanostringData$dict.raw$Name[nanostringData$dict.raw$CodeClass == "Negative"]

dat.neg.df <- reshape::melt(dat.neg, "Gene")
colnames(dat.neg.df)[2:3] <- c("Sample", "Count")


# Negative Table
neg.tab <- round(nanostringDataBG$bg.stats[,1:4], 2)
neg.tab$fail <- paste0(nanostringDataBG$bg.stats$num.less.bg, " (",
                       round(nanostringDataBG$bg.stats$frc.less.bg*100, 1), "%)")
colnames(neg.tab) <- c("Mean (Neg)", "Max (Neg)", "sd (Neg)", "BG (Mean+2sd)", 
                       "Genes below BG (%)")

```

```{r negativeTable}
knitr::kable(neg.tab, padding=2, format="html", row.names = TRUE, align='ccccc') %>%
  kableExtra::kable_styling(full_width = F, position = "center")
```

```{r negativePlot, fig.width = 7, fig.height = 5}
neg1 <- ggplot(data = dat.neg.df, aes(x=Count, y=Sample, 
                                      text=paste0("Sample: ", Sample, "\nGene: ", Gene, "\nCount: ", Count))) +
  geom_jitter(height = 0.2, width = 0, colour = "black", fill = "grey70", pch=21) +
  theme_classic() + ylab("") 

div(ggplotly(neg1, tooltip = c("text"), width = 550, height = 400) %>% 
      layout(margin = list(l=90), autosize = FALSE), 
    align="center")

```

### Housekeeping & Summary

```{r hkPrep, include = FALSE}

# Scale factor table
hk.tab <- data.frame(Sample = names(nanostringData$hk.scalefactors),
                      `Scale Factor` = round(nanostringData$hk.scalefactors, 2))

```

<div class="column-left">
```{r box1, fig.cap = "Boxplot of log2-transformed raw counts of endogenous genes."}
boxplot.dat <- as.data.frame(log2(nanostringData$exprs.raw+0.5))
boxplot.dat$CodeClass <- nanostringData$dict.raw$CodeClass
boxplot.df <- reshape::melt(boxplot.dat, "CodeClass")

b1 <- ggplot() +
  geom_boxplot(data=boxplot.df[boxplot.df$CodeClass == "Endogenous",], 
               aes(x=variable, y=value), fill="grey70") + 
  theme_classic() + xlab("") + ylab("log2(counts+0.5)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

ggplotly(b1) %>% 
      layout(margin = list(b=90))
```

```{r box2, fig.cap = "Boxplot of log2-transformed normalized counts of endogenous genes."}
# boxplot of normalized expression levels

boxplot.dat <- log2(nanostringData$exprs[nanostringData$dict$CodeClass == "Endogenous",]+0.5)
boxplot.df <- reshape::melt(boxplot.dat)

samp.df <- data.frame(sample = rep(colnames(boxplot.dat),times=2),
                      scaleFactor = c(rep("Positive Control", times=ncol(boxplot.dat)), rep("Housekeeping", times=ncol(boxplot.dat))),
                      dat = c(nanostringData$pc.scalefactors,
                      hk.scaleFactor = nanostringData$hk.scalefactors))

b2 <- ggplot() +
  geom_boxplot(data=boxplot.df, aes(x=X2, y=value), fill="grey70") + 
  theme_classic() + xlab("") + ylab("log2(counts+0.5)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

ggplotly(b2) %>% 
      layout(margin = list(b=90))
```

</div>

<div class="column-right">
```{r hkTable}
knitr::kable(hk.tab, padding=2, format="html", row.names = FALSE) %>%
  kableExtra::kable_styling(full_width = F) 
```
</div>



### Old

```{r groups}
knitr::kable(table(limmaResults$sampleData$group), padding=2, format="html",
             col.names = c("Group", "Samples")) %>%
  kableExtra::kable_styling(full_width = F)
```

```{r qc, fig.cap = "Figure 1. Boxplot of log2-transformed raw counts."}
# pre-normalization

boxplot.dat <- as.data.frame(log2(nanostringData$exprs.raw+0.5))
#colnames(boxplot.dat) <- colnames(nanostringData$exprs)
boxplot.dat$CodeClass <- nanostringData$dict.raw$CodeClass
boxplot.df <- reshape::melt(boxplot.dat, "CodeClass")
boxplot.df$group <- as.vector(sapply(limmaResults$sampleData$group, function(x) rep(x, times=nrow(boxplot.dat))))

b1 <- ggplot() +
  geom_boxplot(data=boxplot.df[boxplot.df$CodeClass == "Endogenous",], 
               aes(x=variable, y=value, fill=group)) + 
  geom_jitter(data=boxplot.df[boxplot.df$CodeClass != "Endogenous",], 
              aes(x=variable, y=value, color=CodeClass), width = 0.25, height = 0) +
  theme_classic() + xlab("") + ylab("log2(counts+0.5)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

ggplotly(b1)

```

```{r box, fig.cap = "Figure 2. Boxplot of log2-transformed normalized counts."}
# boxplot of normalized expression levels

boxplot.dat <- log2(nanostringData$exprs[nanostringData$dict$CodeClass == "Endogenous",]+0.5)
boxplot.df <- reshape::melt(boxplot.dat)
boxplot.df$group <- as.vector(sapply(limmaResults$sampleData$group, function(x) rep(x, times=nrow(boxplot.dat))))

samp.df <- data.frame(sample = rep(colnames(boxplot.dat),times=2),
                      scaleFactor = c(rep("Positive Control", times=ncol(boxplot.dat)), rep("Housekeeping", times=ncol(boxplot.dat))),
                      dat = c(nanostringData$pc.scalefactors,
                      hk.scaleFactor = nanostringData$hk.scalefactors))

b2 <- ggplot() +
  geom_boxplot(data=boxplot.df, aes(x=X2, y=value, fill=group)) + 
#  geom_point(data=samp.df, aes(x=sample, y=dat, color = scaleFactor, group=scaleFactor)) + geom_line(data=samp.df, aes(x=sample, y=dat, color = scaleFactor, group=scaleFactor)) +
  theme_classic() + xlab("") + ylab("log2(counts+0.5)") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

ggplotly(b2)
```

## Differential Expression

A principal components analysis is provided in Figure 3, and the numbers of differentially expressed genes (with q < 0.05) are provided in the table below. Differential expression analysis results can be downloaded using the 'Download' button. *Note that this button will work properly when viewing in a browser.*

```{r downloadDiffExprTab}
downloadHandler(
  filename = function() {
      paste("diffExpr-", Sys.Date(), ".txt", sep="")
    },
  content = function(con) {
    makeDiffExprFile(limmaResults, base.group, con,
                     returns = "all")
  }
)
```

```{r pca, fig.cap = "Figure 3. Principal components analysis, using normalized expression of all genes passing background."}

pca.dat <- log2(nanostringData$exprs[nanostringData$dict$CodeClass == "Endogenous" &
                                        rowSums(nanostringData$exprs == 0) == 0,]+0.5)

pca <- prcomp(t(pca.dat),
              center = TRUE, scale = TRUE)
pca.ly <- as.data.frame(pca$x[,1:2])
pca.ly$sample <- row.names(pca$x)
pca.ly$group <- limmaResults$sampleData$group

perc.var <- pca$sdev^2 / sum(pca$sdev^2) * 100

layout.x <- layout.y <- list(
  showline = TRUE,
  showticklabels = TRUE,
  showgrid = FALSE,
  zeroline = FALSE,
  linecolor = toRGB("black"),
  linewidth = 1
)

layout.x$title <- paste0("PC1 (", signif(perc.var[1], 2), "% var)")
layout.y$title <- paste0("PC2 (", signif(perc.var[2], 2), "% var)")

plot_ly(data = pca.ly, x = ~PC1, y = ~PC2,
        text = ~paste0("Sample: ", sample), color = ~group,
        type = "scatter", mode = "markers") %>%
  layout(xaxis = layout.x, yaxis = layout.y)


#library(ggplot2)
#qplot(pca$x[,1], pca$x[,2], 
#      colour = limmaResults$sampleData$group) + 
#  xlab(paste("PC1 (", signif(perc.var[1], 2), "% var)", sep = "")) + 
#  ylab(paste("PC2 (", signif(perc.var[2], 2), "% var)", sep = "")) +
#  labs(col = "Group") 


```

```{r diffExpr}
# table, numbers of differentially expressed genes (shiny p/q/logFC threshold <- should we trust user?)

diffExpr.tab <- rbind(colSums(limmaResults$q.value < 0.05 & limmaResults$coefficients > 0),
                    colSums(limmaResults$q.value < 0.05 & limmaResults$coefficients < 0))
rownames(diffExpr.tab) <- c("Higher in Group", paste0("Higher in ", base.group))

knitr::kable(diffExpr.tab[,-1], padding=2, format="html", 
             col.names = ifelse(ncol(diffExpr.tab)==2, yes = "", no = NA)) %>%
  kableExtra::kable_styling(full_width = F)


```

```{r diffExprTab}
diffExpr.full <- as.data.frame(makeDiffExprFile(limmaResults, base.group, returns = "stats"))

brks.fc <- seq(-2, 2, 4/100)
ln <- length(brks.fc) + 1
cols.fc <- paste0("rgb(",
                  c(round(seq(40, 255, length.out = ln/2), 0), rep(255, times = ln/2)), ",",
                  c(round(seq(40, 255, length.out = ln/2), 0), round(seq(255, 40, length.out = ln/2), 0)), ",",
                  c(rep(255, times = ln/2), round(seq(255, 40, length.out = ln/2), 0)), ")")
brks.qv <- seq(0, 0.1, 0.1/100)
cols.qv <- paste0("rgb(255,", round(seq(40, 255, length.out = length(brks.qv) + 1), 0), ",255)")
dtable <- datatable(diffExpr.full, 
                    options = list(columnDefs = list(list(className = 'dt-center', targets = "_all")))) %>%
  formatStyle(names(diffExpr.full)[substr(names(diffExpr.full), 1, 6) == "Log2FC"], 
              backgroundColor = styleInterval(brks.fc, cols.fc)) %>%
  formatStyle(names(diffExpr.full)[substr(names(diffExpr.full), 1, 5) == "q-val"], 
              backgroundColor = styleInterval(brks.qv, cols.qv))

renderDT({
  dtable
}, rownames = TRUE
)
```

## Gene set analysis {.tabset}

Results of gene set analysis, using the mHG test, are provided in the interactive table below. The comparison of interest (vs. `r base.group`) can be selected in the drop-down box, while the effect direction can also be selected. The clustering threshold can also be specified, with a higher threshold indicating that more overlap of leading edge genes is required to cluster groups together.

```{r gseaSummary}
#select comparison/direction first, then group by distance threshold
#j.thresh <- 0.5 #adjust w/ shiny slider
radioInputs <- c("Higher in Group" = 1,
                 "Higher in Base" = 2)
#names(radioInputs)[2] <- paste0("Higher in ", base.group)

inputPanel(
  selectInput("comp", label = "Comparison:",
              choices = names(genesetResults)),
  radioButtons("dir", label = "Direction:",
              choices = c("Higher in Group" = 1,
                 "Higher in Base" = 2), selected = 1),
  sliderInput("jac", label = "Clustering Threshold (Jaccard Index):",
              min = 0, max = 1, value = 0.5, step = 0.05),
  column(12,
         numericInput("qthresh", label = "q-value threshold:", value = 0.05, step = 0.05),
         numericInput("clust", label = "Cluster to plot:", value = 1, step = 1)
  )
)


leadingEdge <- reactive({
  mHG.to.LEdge.multi(genesetResults, limmaResults$t, 
                     t.thresh = 2, q.thresh = input$qthresh, geneset.file)
})

groupedGenesets <- reactive({
  groupByDistance(genesetResults[[input$comp]][[as.numeric(input$dir)]], 
                                  leadingEdge()[[input$comp]][[as.numeric(input$dir)]], 
                                  join.threshold = (1-input$jac))
})

renderDT({
  datatable(groupedGenesets(),
            rownames = FALSE,
            options = list(autoWidth = TRUE, 
                           columnDefs = list(list(width = '200px', targets = "_all")))) %>%
    formatStyle('best', target = 'row', 
                color = styleEqual(c("", "x"), c('grey', 'black')))
}, rownames = FALSE
)


#renderDT({
#  groupedGenesets()
#}, options = list(
#  autoWidth = TRUE,
#  columnDefs = list(list(width = '200px', targets = "_all"))
#), rownames = FALSE
#)

```

### Heatmap

```{r gseaClusterReport}
# diffExpr stats, expression heatmap, and subluster pathway membership for selected cluster
diffExpr <- makeDiffExprFile(limmaResults, base.group, filename = NULL)
dat.scaled <- diffExpr[,-(1:(3*(ncol(limmaResults$t)-1)))]

hm.max <- 3
dat.scaled[dat.scaled > hm.max] <- hm.max
dat.scaled[dat.scaled < -hm.max] <- -hm.max

acols <- c("grey95", "black")
names(acols) <- c(0, 1)

#annot_row.df <- reactive({
#  subClust <- rownames(groupedGenesets())[groupedGenesets()$Cluster == input$clust]
#  annot_row <- leadingEdge[[input$comp]][[as.numeric(input$dir)]]
#  annot_row <- annot_row[,subClust]
#  annot_row <- as.data.frame(annot_row[rowSums(annot_row) >= 1,])
#  annot_row.df <- sapply(annot_row, as.factor)
#  rownames(annot_row.df) <- rownames(annot_row)
#})

renderPlot({
  subClust <- rownames(groupedGenesets())[groupedGenesets()$Cluster == input$clust]
  annot_row <- leadingEdge()[[input$comp]][[as.numeric(input$dir)]]
  annot_row <- annot_row[,subClust]
  annot_row <- as.data.frame(annot_row)#[rowSums(annot_row) >= 1,])
  annot_row.df <- sapply(annot_row, as.factor)
  rownames(annot_row.df) <- rownames(annot_row)
  
  acols <- list()
  for (i in colnames(annot_row.df)) {
    acols[[i]] <- c("grey95", "black")
    names(acols[[i]]) <- c("0", "1")
  }
  
  pheatmap::pheatmap(dat.scaled[rownames(dat.scaled) %in% rownames(annot_row)[rowSums(annot_row) >= 1],],
                     annotation_col = limmaResults$sampleData,
                     annotation_row = annot_row, annotation_colors = acols,
                     color = colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdBu")))(100),
                     breaks = seq(-hm.max, hm.max, by=2*hm.max/100),
                     cluster_cols = FALSE, cluster_rows = TRUE, border_color = "white",
                     fontsize = 7, fontsize_row=10, fontsize_col=10, drop_levels = FALSE, annotation_legend=F)
},  height=700, width=600)

```

### Download

```{r downloadGSEA}

inputPanel(
  radioButtons("dl", label = "Download:",
                choices = c("Full Results" = 1,
                "Selected Comparison" = 2,
                "Selected Cluster" = 3), selected = 1),

  downloadHandler(
    filename = function() {
        paste("results-",
              ifelse(input$dl == 1, yes = "full-", 
                     no = paste0("comp", input$comp, "-", input$dir, "-")),
              ifelse(input$dl == 3, yes = paste0("clust", input$clust, "-"), no = ""),
              Sys.Date(), ".txt", sep="")
      },
    content = function(con) {
      if (input$dl == 1) {
        #make.mHG.master.table is trouble b/c LEdge/cluster are reactive b/c we have interactive t/q-thresh.
      } else if (input$dl == 2) {
        prep.stackedReport.from.grouped.mHG(groupedGenesets(), 
                                            leadingEdge()[[input$comp]][[as.numeric(input$dir)]], 
                                            limmaResults, base.group, filename = con) #not workin'
      } else {
        
      }
    }
  )
)
```
